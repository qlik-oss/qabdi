## Global Docker image registry
## Please, note that this will override the image registry for all the images, including dependencies, configured to use the global value
##
# global:
#   imageRegistry:

## NATS Streaming image
##
image:
  registry: qliktech-docker.jfrog.io
  repository: nats-streaming
  tag: 0.14.2
  ## Specify a imagePullPolicy
  ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
  ## ref: http://kubernetes.io/docs/user-guide/images/#pre-pulling-images
  ##
  pullPolicy: IfNotPresent
  ## Optionally specify an array of imagePullSecrets.
  ## Secrets must be manually created in the namespace.
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
  ##
  pullSecrets:
    - name: artifactory-docker-secret

## NATS Streaming replicas
replicaCount: 3

#
# Streaming server configuration
#

## NATS Streaming cluster id
clusterID: "{{ .Release.Name }}-nats-streaming-cluster"

## NATS server
natsSvc: "nats://{{ .Release.Name }}-nats-client:4222"

# Max number of channels (0 for unlimited)
maxChannels: 100

# Max number of subscriptions per channel (0 for unlimited)
maxSubs: 1000

# Max number of messages per channel (0 for unlimited)
maxMsgs: "1000000"

# Max messages total size per channel (0 for unlimited)
maxBytes: "900mb"

# Max duration a message can be stored ("0s" for unlimited)
maxAge: "2h"

#
# ADVANCED CONFIGURATION:  Change these with caution.
#

# Interval at which server sends heartbeat to a client
hbInterval: 10s

# How long server waits for a heartbeat response
hbTimeout: 10s

# Number of failed heartbeats before server closes the client connection
hbFailCount: 5

# Use for general debugging. Enabling this will negatively affect performance.
debug: true

# Do not normally set this as it will drastically decrease performance and generate
# volumous logs.
trace: false

# Run NATS Streaming in clustered mode (incompatible with ftGroup value)
# https://github.com/nats-io/nats-streaming-server#clustering
clustered: true

# Use for raft related debugging
cluster_raft_logging: false

# Run NATS Streaming in fault tolerance mode with this group name (incompatible with clustered value)
# https://github.com/nats-io/nats-streaming-server#fault-tolerance
# ftGroup: "myGroupName"

store: "file"

file:
  #  Enable compaction
  compactEnabled: true

  # Enable file CRC-32 checksum
  crc: true

  # Enable File.Sync on Flush
  sync: true

  # Store will try to use no more file descriptors than this given limit
  fdsLimit: 0

  ##
  ## ADVANCED CONFIGURATION:  Change these with caution.
  ##
  # File buffer size (in bytes)
  bufferSize: "2097152"

  # File fragmentation % threshold for compaction
  compactFrag: 50

  # Minimum interval (in seconds) between file compactions, 5min
  compactInterval: 300

  #  Minimum file size for compaction
  compactMinSize: "1048576"

  # Polynomial used to make the table used for CRC-32 checksum (default is crc32.IEEE)
  crcPoly: "3988292384"

  # Maximum number of messages per file slice (subject to channel limits)
  sliceMaxMsgs: 0

  # Maximum file slice size - including index file (subject to channel limits)  64MB
  sliceMaxBytes: "67108931"

  # Maximum file slice duration starting when the first message is stored (subject to channel limits)
  sliceMaxAge: 0

  # Path to script to use if you want to archive a file slice being removed
  sliceArchiveScript: ""

  #  On startup, number of channels that can be recovered in parallel
  parallelRecovery: 1

persistence:
  ## If false, emptyDir will be used as a volume.
  enabled: false
  # size: 10Gi
  # storageClass: ""
  internalStorageClass:
    ## Normally the storage class should be created outside this helm chart
    ## If we want to deploy a storage class as part of the helm chart
    ## - Provide a storageClassName above.
    ## - set enabled true
    ## - provide a storage class definition.

    ## If enabled storage class will be configured as part of the chart.
    ## If not enabled an external storageclass can be used by providing storageClassName above.
    enabled: false

    ## Storageclass definition
    definition: {}
    ## Storage classes have a provisioner that determines what volume plugin is used for provisioning PVs.
    ## This field must be specified.
    ## See https://kubernetes.io/docs/concepts/storage/storage-classes/
    #  provisioner: kubernetes.io/no-provisioner

    ## Reclaim policy should normally be set to Retain to avoid loosing data when deleting this helm chart.
    # reclaimPolicy: Retain

    ## Persistent Volumes that are dynamically created by a storage class will have the mount options specified
    ## in the mountOptions field of the class.
    #  mountOptions: {}

    ## Storage classes have parameters that describe volumes belonging to the storage class.
    ## Different parameters may be accepted depending on the provisioner.
    #  parameters: {}

## NATS Pod Security Context
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
##
securityContext:
  enabled: false
  fsGroup: 1001
  runAsUser: 1001

## NATS Streaming Node selector and tolerations for pod assignment
## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#taints-and-tolerations-beta-feature
##
# nodeSelector: {"beta.kubernetes.io/arch": "amd64"}
# tolerations: []

## Use an alternate scheduler, e.g. "stork".
## ref: https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/
##
# schedulerName:

## Pods anti-affinity
## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
##
antiAffinity: soft

## Pod annotations
## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
##
podAnnotations: {}
  ## Annotations for Promethues metrics
  # prometheus.io/scrape: "true"
  # prometheus.io/port: "7777"

## Additional pod labels
## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
##
podLabels: {}

## Update strategy, can be set to RollingUpdate or OnDelete by default.
## https://kubernetes.io/docs/tutorials/stateful-application/basic-stateful-set/#updating-statefulsets
statefulset:
  updateStrategy: RollingUpdate
  ## Partition update strategy
  ## https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions
  # rollingUpdatePartition:

## Configure resource requests and limits
## ref: http://kubernetes.io/docs/user-guide/compute-resources/
##
resources: {}
# limits:
#   cpu: 500m
#   memory: 512Mi
# requests:
#   cpu: 100m
#   memory: 256Mi

## Configure extra options for liveness and readiness probes
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#configure-probes)
livenessProbe:
  enabled: true
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 6
  successThreshold: 1
readinessProbe:
  enabled: true
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 6
  successThreshold: 1

## Client Authentication
## ref: https://github.com/nats-io/nats-streaming-server#authorization
##
auth:
  enabled: false
  # user: nats_client
  # password:
  # token:
  secretName: "{{ .Release.Name }}-nats-secret"
  secretClientUser: "client-user"
  secretClientPassword: "client-password"

## Network pullPolicy
## https://kubernetes.io/docs/concepts/services-networking/network-policies/
##
networkPolicy:
  ## Enable creation of NetworkPolicy resources.
  enabled: false
  ## TODO  remove after merging messaging v3.0.0
  nats-streaming:
    enabled: false

## NATS Streaming svc used for monitoring
## ref: https://github.com/nats-io/gnatsd#monitoring
##
monitoring:
  service:
    ## Kubernetes service type
    type: ClusterIP
    port: 8222
    ## Specify the nodePort value for the LoadBalancer and NodePort service types.
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
    ##
    # nodePort:
    ## Provide any additional annotations which may be required. This can be used to
    ## set the LoadBalancer service type to internal only.
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#internal-load-balancer
    ##
    # Annotations for Promethues
    annotations:
      prometheus.io/scrape: "true"
      prometheus.io/port: "7777"
    ## Use loadBalancerIP to request a specific static IP,
    ## otherwise leave blank
    ##
    loadBalancerIP:

## Metrics / Prometheus NATS Exporter
##
## ref: https://github.com/nats-io/prometheus-nats-exporter
metrics:
  enabled: false
  image:
    registry: qliktech-docker.jfrog.io
    repository: prometheus-nats-exporter
    tag: 0.3.0
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ##
    pullSecrets:
      - name: artifactory-docker-secret
  ## Metrics exporter resource requests and limits
  ## ref: http://kubernetes.io/docs/user-guide/compute-resources/
  ##
  # resources: {}
  ## Metrics exporter port
  port: 7777
  ## Metrics exporter annotations
  podAnnotations:
    prometheus.io/scrape: "false"  # prometheus annotations are added on the monitoring service instead
    prometheus.io/port: "7777"
    ## Metrics exporter flags
  args:
    - -channelz
    - -serverz

## Sidecars
sidecars:
  ## e.g.
  # - name: your-image-name
    # image: your-image
    # imagePullPolicy: Always
    # ports:
    # - name: portname
  #   containerPort: 1234
